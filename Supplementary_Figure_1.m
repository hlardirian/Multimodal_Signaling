%% load data 

load('Z:\bkramer\190218_184A1_EGF\Data_Analysis\CleanCode\Data_1.mat')
addpath(genpath('Z:\bkramer\190218_184A1_EGF\Data_Analysis\CleanCode\'));
javaaddpath('Z:\bkramer\190218_184A1_EGF\Data_Analysis\CleanCode\Functions\umapFileExchange (1.2.1)\umap\umap.jar');


%% Data description

% LinearIndex: Indicator to which condition each cell (i.e. row) belongs; Individual numbers denote replicates %
% 1,2,3,11,21,22,23,24,25,26,27,28,29,30 - 100ng/ml EGF
% 4,5,6 - 25ng/ml EGF
% 7,8,9 - 10ng/ml EGF
% 10,19,20 - 6.25ng/ml EGF
% 16,17,18 - 1ng/ml EGF
% 13,14,15 - 0ng/ml EGF
% 11,12,21,22,23,24,25,26,27,28,29,30 - 100ng/ml control for intensity decay and secondary antibody only controls after elution (see Gut et al. for details): 12: Cycle 01, 11: Cycle 02, 21: Cycle 03, 22: Cycle 04 etc... 30 always secondary only. Starting at 12... etc again when 29 was reached

% FeatureHeader: Descriptor of which cellular state feature (column) is represented in the corresponding double matrices %
% FeatureData: Contains raw (and transformed, see material and methods) single cell cellular state feature data; columns correspoding to cellular state features described in "FeatureHeader" %
% FeatureZData: Contains the z-scored (see material and methods) single cell cellular state feature data; columns corresponding to cellular state features described in "FeatureHeader" %

% MetaHeader: Descriptor of which MetaData (e.g. CentroidLocation in image, or which field in an image) is represented in the corresponding double matrices %
% MetaData: Contains single cell information on the Metadata; columns corresponding to information described in "MetaHeader"

% ResponseHeader: Descriptor of which response (column) is represented in the corresponding double matrices %
% ResponseData: Contains raw single cell data; columns corresponding to response features described in "ResponseHeader" %
% LogResponseData: Contains transformed (see material and methods) single cell data; columns corresponding to response features described in "ResponseHeader" %

% PCCoeff: Contains the loadings of each principal component from principal component analysis on cellular state features (FeatureZData)
% PCFeatureData: Contains single cell data of cellular state features (from FeatureZData) transformed to PCs). Only the PCs which together explain 97.5% of the variance are kept (hence only 157)

% WeightedClusterData: Data from PCFeatureData weighted as described in material and methods and used as input for fuzzy clustering. Columns correspond to the PCs used; further described in script for Figure 3; Only clustered on cells belong to LinearIndex 1,2,3,4,5,6,7,8,9,10,13,14,15 and 20 %
% ClusterCenter: Centroid locations for the individual cluster centers obtained from fuzzy clustering on cellular state features %
% MembershipData: Contains the Membership degree (Fuzzy clustering outputs degrees of membership, no clear assignement) for each single cell)

%% Supplementary Figure 1A

% Assembled in Adobe Illustrator and with Fiji; ai. and raw images can be shared

%% Supplementary Figure 1B

% Assembled in Adobe Illustrator and with Fiji; ai. and raw images can be shared


%% Supplementary Figure 1C

% Assembled in Adobe Illustrator and with Fiji; ai. and raw images can be shared


%% Supplementary Figure 1D

% Assembled in Adobe Illustrator and with Fiji; ai. and raw images can be shared; Raw plots used are generated by the following


% R01 pERK vs. R07 pERK


StorageSignalOne = [];
StorageSignalTwo = [];
GroupIndex = [];

WellGroups = {[1,2,3],[4,5,6],[7,8,9],[10,19,20],[13,14,15]};


for CurrentWell = 1:size(WellGroups,2)
    WellIndex = find(ismember(LinearIndex,WellGroups{1,CurrentWell}));
    StorageSignalOne = [StorageSignalOne;LogResponseData(WellIndex,3)];
    StorageSignalTwo = [StorageSignalTwo;LogResponseData(WellIndex,138)];
    GroupIndex = [GroupIndex;ones(size(WellIndex,1),1)*CurrentWell];
end

RandomShuffle = randperm(size(GroupIndex,1),size(GroupIndex,1));

figure
scatter(StorageSignalOne(RandomShuffle),StorageSignalTwo(RandomShuffle),4,GroupIndex(RandomShuffle),'filled');
corr(StorageSignalOne,StorageSignalTwo)

% R01 pERK vs. R13 pERK

StorageSignalOne = [];
StorageSignalTwo = [];
GroupIndex = [];

WellGroups = {[1,2,3],[4,5,6],[7,8,9],[10,19,20],[13,14,15]};


for CurrentWell = 1:size(WellGroups,2)
    WellIndex = find(ismember(LinearIndex,WellGroups{1,CurrentWell}));
    StorageSignalOne = [StorageSignalOne;LogResponseData(WellIndex,3)];
    StorageSignalTwo = [StorageSignalTwo;LogResponseData(WellIndex,213)];
    GroupIndex = [GroupIndex;ones(size(WellIndex,1),1)*CurrentWell];
end

RandomShuffle = randperm(size(GroupIndex,1),size(GroupIndex,1));

figure
scatter(StorageSignalOne(RandomShuffle),StorageSignalTwo(RandomShuffle),4,GroupIndex(RandomShuffle),'filled');
corr(StorageSignalOne,StorageSignalTwo)


% R07 pERK vs. R13 pERK

StorageSignalOne = [];
StorageSignalTwo = [];
GroupIndex = [];

WellGroups = {[1,2,3],[4,5,6],[7,8,9],[10,19,20],[13,14,15]};


for CurrentWell = 1:size(WellGroups,2)
    WellIndex = find(ismember(LinearIndex,WellGroups{1,CurrentWell}));
    StorageSignalOne = [StorageSignalOne;LogResponseData(WellIndex,138)];
    StorageSignalTwo = [StorageSignalTwo;LogResponseData(WellIndex,213)];
    GroupIndex = [GroupIndex;ones(size(WellIndex,1),1)*CurrentWell];
end

RandomShuffle = randperm(size(GroupIndex,1),size(GroupIndex,1));

figure
scatter(StorageSignalOne(RandomShuffle),StorageSignalTwo(RandomShuffle),4,GroupIndex(RandomShuffle),'filled');
corr(StorageSignalOne,StorageSignalTwo)


%% Supplementary Figure 1E

% Assembled in Adobe Illustrator; ai. can be shared; Raw plots used are generated by the following

ResponseCell = [1,2,3];

CurrentStain = 3;
Eval = 0:0.05:12;


% Outline Distributions
% 1 versus 2

figure
hold on


CurrentWells = ResponseCell(1);
WellIndex = find(ismember(LinearIndex,CurrentWells));
WellOneData = LogResponseData(WellIndex,CurrentStain);
%     if CurrentWellCell == 1
%         WellResponseData(WellResponseData >= 4) = [];
%     end

CurrentWells = ResponseCell(2);
WellIndex = find(ismember(LinearIndex,CurrentWells));
WellTwoData = LogResponseData(WellIndex,CurrentStain);
%     if CurrentWellCell == 1
%         WellResponseData(WellResponseData >= 4) = [];
%     end

DensityOne = ksdensity(WellOneData,Eval);
DensityTwo = ksdensity(WellTwoData,Eval);
MaxDensity = max([DensityOne,DensityTwo]);
MinDensity = min([DensityOne;DensityTwo]);

area(Eval,MinDensity)
plot(Eval,DensityOne)
plot(Eval,DensityTwo)
xlim([8 11.3])
ylim([0 1])


% 1 versus 3

figure
hold on


CurrentWells = ResponseCell(1);
WellIndex = find(ismember(LinearIndex,CurrentWells));
WellOneData = LogResponseData(WellIndex,CurrentStain);
%     if CurrentWellCell == 1
%         WellResponseData(WellResponseData >= 4) = [];
%     end

CurrentWells = ResponseCell(3);
WellIndex = find(ismember(LinearIndex,CurrentWells));
WellTwoData = LogResponseData(WellIndex,CurrentStain);
%     if CurrentWellCell == 1
%         WellResponseData(WellResponseData >= 4) = [];
%     end

DensityOne = ksdensity(WellOneData,Eval);
DensityTwo = ksdensity(WellTwoData,Eval);
MaxDensity = max([DensityOne,DensityTwo]);
MinDensity = min([DensityOne;DensityTwo]);

area(Eval,MinDensity)
plot(Eval,DensityOne)
plot(Eval,DensityTwo)
xlim([8 11.3])
ylim([0 1])



% 2 versus 3

figure
hold on


CurrentWells = ResponseCell(2);
WellIndex = find(ismember(LinearIndex,CurrentWells));
WellOneData = LogResponseData(WellIndex,CurrentStain);
%     if CurrentWellCell == 1
%         WellResponseData(WellResponseData >= 4) = [];
%     end

CurrentWells = ResponseCell(3);
WellIndex = find(ismember(LinearIndex,CurrentWells));
WellTwoData = LogResponseData(WellIndex,CurrentStain);
%     if CurrentWellCell == 1
%         WellResponseData(WellResponseData >= 4) = [];
%     end

DensityOne = ksdensity(WellOneData,Eval);
DensityTwo = ksdensity(WellTwoData,Eval);
MaxDensity = max([DensityOne,DensityTwo]);
MinDensity = min([DensityOne;DensityTwo]);

area(Eval,MinDensity)
plot(Eval,DensityOne)
plot(Eval,DensityTwo)
xlim([8 11.3])
ylim([0 1])

%% Supplementary Figure 1F

StorageDoseOverlap = cell(5,1);

% 0ng EGF

TestWells = [15,14,13];
FavoriteStains = [18,168,3,123,153,108,33,91,61,78,87,91,95,98,101,108,111,115,119,121,125,129,130,133,146,148,154,158];%[18,168,3,123,153,108,33,91,61,78,92,96,100,104,108,116,120,124,128,130,136,140,142,146,164,166,172,176];%[18,168,3,123,153,108,33,91,61,78];
StorageOverlap = zeros(3,size(FavoriteStains,2));

% One with Two
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(2)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(1,CurrentStainIndex) = Overlap;
end

% One with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(2,CurrentStainIndex) = Overlap;
end


% Two with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(2)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(3,CurrentStainIndex) = Overlap;
end


StorageDoseOverlap{1,1} = StorageOverlap;


% 6.25ng EGF

TestWells = [10,20,19];
FavoriteStains = [18,168,3,123,153,108,33,91,61,78,87,91,95,98,101,108,111,115,119,121,125,129,130,133,146,148,154,158];%[18,168,3,123,153,108,33,91,61,78,92,96,100,104,108,116,120,124,128,130,136,140,142,146,164,166,172,176];%[18,168,3,123,153,108,33,91,61,78];
StorageOverlap = zeros(3,size(FavoriteStains,2));

% One with Two
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(2)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(1,CurrentStainIndex) = Overlap;
end

% One with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(2,CurrentStainIndex) = Overlap;
end


% Two with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(2)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(3,CurrentStainIndex) = Overlap;
end


StorageDoseOverlap{2,1} = StorageOverlap;


% 10ng EGF

TestWells = [7,8,9];
FavoriteStains = [18,168,3,123,153,108,33,91,61,78,87,91,95,98,101,108,111,115,119,121,125,129,130,133,146,148,154,158];%[18,168,3,123,153,108,33,91,61,78,92,96,100,104,108,116,120,124,128,130,136,140,142,146,164,166,172,176];%[18,168,3,123,153,108,33,91,61,78];
StorageOverlap = zeros(3,size(FavoriteStains,2));

% One with Two
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(2)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(1,CurrentStainIndex) = Overlap;
end

% One with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(2,CurrentStainIndex) = Overlap;
end


% Two with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(2)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(3,CurrentStainIndex) = Overlap;
end


StorageDoseOverlap{3,1} = StorageOverlap;


% 25ng EGF

TestWells = [4,5,6];
FavoriteStains = [18,168,3,123,153,108,33,91,61,78,87,91,95,98,101,108,111,115,119,121,125,129,130,133,146,148,154,158];%[18,168,3,123,153,108,33,91,61,78,92,96,100,104,108,116,120,124,128,130,136,140,142,146,164,166,172,176];%[18,168,3,123,153,108,33,91,61,78];
StorageOverlap = zeros(3,size(FavoriteStains,2));

% One with Two
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(2)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(1,CurrentStainIndex) = Overlap;
end

% One with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(2,CurrentStainIndex) = Overlap;
end


% Two with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(2)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(3,CurrentStainIndex) = Overlap;
end


StorageDoseOverlap{4,1} = StorageOverlap;


% 100ng EGF

TestWells = [1,2,3];
FavoriteStains = [18,168,3,123,153,108,33,91,61,78,87,91,95,98,101,108,111,115,119,121,125,129,130,133,146,148,154,158];%[18,168,3,123,153,108,33,91,61,78,92,96,100,104,108,116,120,124,128,130,136,140,142,146,164,166,172,176];%[18,168,3,123,153,108,33,91,61,78];
StorageOverlap = zeros(3,size(FavoriteStains,2));

% One with Two
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(2)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(1,CurrentStainIndex) = Overlap;
end

% One with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(1)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(2,CurrentStainIndex) = Overlap;
end


% Two with Three
Eval = -12:0.01:12;

for CurrentStainIndex = 1:size(FavoriteStains,2)
    
    CurrentStain = FavoriteStains(1,CurrentStainIndex);
    WellOne = find(ismember(LinearIndex,TestWells(2)));
    WellTwo = find(ismember(LinearIndex,TestWells(3)));
    
    if CurrentStainIndex <= 10
        WellOneData = LogResponseData(WellOne,CurrentStain);
        WellTwoData = LogResponseData(WellTwo,CurrentStain);
    else
        WellOneData = FeatureData(WellOne,CurrentStain);
        WellTwoData = FeatureData(WellTwo,CurrentStain);
    end
    
    DensityOne = ksdensity(WellOneData,Eval);
    DensityTwo = ksdensity(WellTwoData,Eval);
    MaxDensity = max([DensityOne,DensityTwo]);
    
    DensityGrid = 0:0.001:MaxDensity+0.001;
    EvaluateGrid = meshgrid(DensityGrid,Eval)';
    DifferenceOne = EvaluateGrid - DensityOne;
    DifferenceTwo = EvaluateGrid - DensityTwo;
    
    NegativeOne = find(DifferenceOne < 0);
    NegativeTwo = find(DifferenceTwo < 0);
    
    CommonNegative = intersect(NegativeOne,NegativeTwo);
    
    Overlap = numel(CommonNegative)/numel(NegativeOne);
    StorageOverlap(3,CurrentStainIndex) = Overlap;
end


StorageDoseOverlap{5,1} = StorageOverlap;


MeanOverlap = zeros(1,28);
StdOverlap = zeros(1,28);
for CurrentDose = 1
    CurrentOverlap = StorageDoseOverlap{CurrentDose,1};
    MeanOverlap = mean(CurrentOverlap);
    StdOverlap = std(CurrentOverlap);
end



figure
hold on
bar(MeanOverlap)
xlim([0 29])
er = errorbar(1:28,MeanOverlap,StdOverlap,StdOverlap);    
er.Color = [0 0 0];                            
er.LineStyle = 'none';  


