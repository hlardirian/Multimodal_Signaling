%% load data 
% Adjust path to wherever data and function folder is located
load('Z:\bkramer\190218_184A1_EGF\Data_Analysis\CleanCode\Data_1.mat')
addpath(genpath('Z:\bkramer\190218_184A1_EGF\Data_Analysis\'));
javaaddpath('Z:\bkramer\190218_184A1_EGF\Data_Analysis\Functions\umapFileExchange (1.2.1)\umap\umap.jar');


%% Data description

% LinearIndex: Indicator to which condition each cell (i.e. row) belongs; Individual numbers denote replicates %
% 1,2,3,11,21,22,23,24,25,26,27,28,29,30 - 100ng/ml EGF
% 4,5,6 - 25ng/ml EGF
% 7,8,9 - 10ng/ml EGF
% 10,19,20 - 6.25ng/ml EGF
% 16,17,18 - 1ng/ml EGF
% 13,14,15 - 0ng/ml EGF
% 11,12,21,22,23,24,25,26,27,28,29,30 - 100ng/ml control for intensity decay and secondary antibody only controls after elution (see Gut et al. for details): 11: Cycle 1, 12: Cycle 2 etc... 30 always secondary only. Starting at 11... etc again when 29 was reached

% FeatureHeader: Descriptor of which cellular state feature (column) is represented in the corresponding double matrices %
% FeatureData: Contains raw (and transformed, see material and methods) single cell cellular state feature data; columns correspoding to cellular state features described in "FeatureHeader" %
% FeatureZData: Contains the z-scored (see material and methods) single cell cellular state feature data; columns corresponding to cellular state features described in "FeatureHeader" %

% MetaHeader: Descriptor of which MetaData (e.g. CentroidLocation in image, or which field in an image) is represented in the corresponding double matrices %
% MetaData: Contains single cell information on the Metadata; columns corresponding to information described in "MetaHeader"

% ResponseHeader: Descriptor of which response (column) is represented in the corresponding double matrices %
% ResponseData: Contains raw single cell data; columns corresponding to response features described in "ResponseHeader" %
% LogResponseData: Contains transformed (see material and methods) single cell data; columns corresponding to response features described in "ResponseHeader" %

% PCCoeff: Contains the loadings of each principal component from principal component analysis on cellular state features (FeatureZData)
% PCFeatureData: Contains single cell data of cellular state features (from FeatureZData) transformed to PCs). Only the PCs which together explain 97.5% of the variance are kept (hence only 157)

% MSTData: Relic from the past; not used in the paper %
% MSTHeader: Relic from the past; not used in the paper %

% WeightedClusterData: Data from PCFeatureData weighted as described in material and methods and used as input for fuzzy clustering. Columns correspond to the PCs used; further described in script for Figure 3; Only clustered on cells belong to LinearIndex 1,2,3,4,5,6,7,8,9,10,13,14,15 and 20 %
% ClusterCentor: Centroid locations for the individual cluster centers obtained from fuzzy clustering on cellular state features %
% MembershipData: Contains the Membership degree (Fuzzy clustering outputs degrees of membership, no clear assignement) for each single cell)

%% Figure 2A 

% Assembled in Adobe Illustrar; ai. can be shared - Raw plots used are generated by the following

% Scatter plot measured versus predicted of pERK at 100ng/ml

% Replicate 1
StorageTrue = [];
StoragePrediction = [];

PredWell = 1;
InWells = [2,3];
PredIndex = find(ismember(LinearIndex,PredWell));
IndIndex = find(ismember(LinearIndex,InWells));
CurrentResponse = 3;

CurrentIndependentData = PCFeatureData(IndIndex,:);
CurrentResponseData = LogResponseData(IndIndex,CurrentResponse); 

TrueResponseData = LogResponseData(PredIndex,CurrentResponse);
TrueIndependentData = PCFeatureData(PredIndex,:);

MDL = cvglmnet(CurrentIndependentData,CurrentResponseData);
Prediction = cvglmnetPredict(MDL,TrueIndependentData);

StorageTrue = [StorageTrue;TrueResponseData];
StoragePrediction = [StoragePrediction;Prediction];

% Replicate 2

PredWell = 2;
InWells = [1,3];
PredIndex = find(ismember(LinearIndex,PredWell));
IndIndex = find(ismember(LinearIndex,InWells));
CurrentResponse = 3;


CurrentIndependentData = PCFeatureData(IndIndex,:);
CurrentResponseData = LogResponseData(IndIndex,CurrentResponse); 

TrueResponseData = LogResponseData(PredIndex,CurrentResponse);
TrueIndependentData = PCFeatureData(PredIndex,:);

MDL = cvglmnet(CurrentIndependentData,CurrentResponseData);
Prediction = cvglmnetPredict(MDL,TrueIndependentData);

StorageTrue = [StorageTrue;TrueResponseData];
StoragePrediction = [StoragePrediction;Prediction];


% Replicate 3

PredWell = 3;
InWells = [1,2];
PredIndex = find(ismember(LinearIndex,PredWell));
IndIndex = find(ismember(LinearIndex,InWells));
CurrentResponse = 3;


CurrentIndependentData = PCFeatureData(IndIndex,:);
CurrentResponseData = LogResponseData(IndIndex,CurrentResponse); 

TrueResponseData = LogResponseData(PredIndex,CurrentResponse);
TrueIndependentData = PCFeatureData(PredIndex,:);

MDL = cvglmnet(CurrentIndependentData,CurrentResponseData);
Prediction = cvglmnetPredict(MDL,TrueIndependentData);

StorageTrue = [StorageTrue;TrueResponseData];
StoragePrediction = [StoragePrediction;Prediction];


% Sort True data for plotting

[SortedTrueData,SortIndex] = sort(StorageTrue,'ascend');
SortedPredictionData = StoragePrediction(SortIndex,:);

fitresult = fit(SortedTrueData,SortedPredictionData,'poly1');
p22 = predint(fitresult, SortedTrueData,0.95,'observation','off');

figure
S = scatter(SortedTrueData,SortedPredictionData,4,'o','filled','MarkerFaceColor','k','MarkerEdgeColor','none');
S.MarkerFaceAlpha = 0.2;
hold on
plot(fitresult)
hold on
xlim([7 12])
ylim([7.55 11.45])
axis square

legend off
axis off


% Calculation of RSquared (Depends on the way it's calculated and the crossevaluation set(varies between 0.83 and 0.85); here we use the most "canonical" definition)
CurrentWells = [1,2,3];
CurrentWellIndex = find(ismember(LinearIndex,CurrentWells));
CellFeatureData = PCFeatureData(CurrentWellIndex,:);
CellResponseData = LogResponseData(CurrentWellIndex,3);
MDL = cvglmnet(CellFeatureData,CellResponseData);
Prediction = cvglmnetPredict(MDL,CellFeatureData);

SSTotal = sum((CellResponseData - mean(CellResponseData)).^2);
Residuals = CellResponseData - Prediction;
SSResidual = sum(Residuals.^2);
RSquared = 1 - SSResidual/SSTotal;


% Generate UMAP - CAVEAT!!!!! EVERY UMAP RUN CAN DIFFER
WellIndex = find(ismember(LinearIndex,[1,2,3,4,5,6,7,8,9,10,19,20,13,14,15]));
% NumberNeighbors = 30;
% DistanceMetric = 'cityblock';
% [ReductionUmap,UMAPCoord] = run_umap(ReducedPCFeatureData(WellIndex,:),'n_neighbors',NumberNeighbors,'metric',DistanceMetric);
ReducedLinearIndex = LinearIndex(WellIndex);


ReducedResponseData = LogResponseData(WellIndex,:);
ReducedFeatureData = PCFeatureData(WellIndex,:);
CurrentResponseVector = [3,61,78];
NameCell = {'pERK','FoxO3a','pS6'};

WellGroups = {[1,2,3],[4,5,6],[7,8,9],[10,19,20],[13,14,15]};
ConcentrationString = {'100ng','25ng','10ng','6.25ng','0ng'};
for CurrentResponseIndex = 1:3%1:3
    CurrentResponse = CurrentResponseVector(CurrentResponseIndex);
    for CurrentGroup = 1
        % Plot Measured
        CurrentWells = WellGroups{1,CurrentGroup};
        CurrentWellIndex = find(ismember(ReducedLinearIndex,CurrentWells));
        
        CellResponseData = zscore(ReducedResponseData(CurrentWellIndex,CurrentResponse));
        figure
        scatter(ReductionUmap(CurrentWellIndex,1),ReductionUmap(CurrentWellIndex,2),4,CellResponseData,'filled');
        caxis([-2 2])
        colormap(flipud(brewermap(500,'PiYG')))
        ylim([-4.3 6.8])
        xlim([-7.5 10.5])
        set(gcf,'position',[2963 -211 590.8 450])
        axis off
        
        
        set(gcf,'position',[2963 -211 590.8 450])
        axis on
        colorbar
     

        StoragePrediction = [];
        
        % Predict Replicate one
        TrueWell = CurrentWells(1);
        IndWell = CurrentWells(2:3);
        
        WellIndexTrue = find(ismember(ReducedLinearIndex,TrueWell));
        WellIndexInd = find(ismember(ReducedLinearIndex,IndWell));
        
        TrueResponseData = zscore(ReducedResponseData(WellIndexTrue,CurrentResponse));
        IndResponseData = zscore(ReducedResponseData(WellIndexInd,CurrentResponse));
        
        TrueFeatureData = ReducedFeatureData(WellIndexTrue,:);
        IndFeatureData = ReducedFeatureData(WellIndexInd,:);
        
        MDL = cvglmnet(IndFeatureData,IndResponseData);
        Prediction = cvglmnetPredict(MDL,TrueFeatureData);
        
        CurrentNormData = Prediction;

        Iterations = 20;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([TrueResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        StoragePrediction = [StoragePrediction;CurrentNormData];
        
        % Predict Replicate two
        TrueWell = CurrentWells(2);
        IndWell = CurrentWells([1,3]);
        
        WellIndexTrue = find(ismember(ReducedLinearIndex,TrueWell));
        WellIndexInd = find(ismember(ReducedLinearIndex,IndWell));
        
        TrueResponseData = zscore(ReducedResponseData(WellIndexTrue,CurrentResponse));
        IndResponseData = zscore(ReducedResponseData(WellIndexInd,CurrentResponse));
        
        TrueFeatureData = ReducedFeatureData(WellIndexTrue,:);
        IndFeatureData = ReducedFeatureData(WellIndexInd,:);
        
        MDL = cvglmnet(IndFeatureData,IndResponseData);
        Prediction = cvglmnetPredict(MDL,TrueFeatureData);
        
        CurrentNormData = Prediction;

        Iterations = 20;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([TrueResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        StoragePrediction = [StoragePrediction;CurrentNormData];
        
        % Predict Replicate three
        TrueWell = CurrentWells(3);
        IndWell = CurrentWells(1:2);
        
        WellIndexTrue = find(ismember(ReducedLinearIndex,TrueWell));
        WellIndexInd = find(ismember(ReducedLinearIndex,IndWell));
        
        TrueResponseData = zscore(ReducedResponseData(WellIndexTrue,CurrentResponse));
        IndResponseData = zscore(ReducedResponseData(WellIndexInd,CurrentResponse));
        
        TrueFeatureData = ReducedFeatureData(WellIndexTrue,:);
        IndFeatureData = ReducedFeatureData(WellIndexInd,:);
        
        MDL = cvglmnet(IndFeatureData,IndResponseData);
        Prediction = cvglmnetPredict(MDL,TrueFeatureData);
        
        CurrentNormData = Prediction;

        Iterations = 20;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([TrueResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        StoragePrediction = [StoragePrediction;CurrentNormData];
        
        figure
        scatter(ReductionUmap(CurrentWellIndex,1),ReductionUmap(CurrentWellIndex,2),4,StoragePrediction,'filled');
        caxis([-2 2])
        colormap(flipud(brewermap(500,'PiYG')))      
        
        ylim([-4.3 6.8])
        xlim([-7.5 10.5])
        set(gcf,'position',[2963 -211 590.8 450])
        axis off
        
        set(gcf,'position',[2963 -211 590.8 450])
        axis on
        colorbar

        
                 
        colorbar
        
        % Calculation of RSquared - Depends on the way it's calculated and the crossevaluation set(varies by about ~0.03 for each stain); here we use the most "canonical" definition
        CurrentWellIndex = find(ismember(LinearIndex,CurrentWells));
        CellFeatureData = PCFeatureData(CurrentWellIndex,:);
        CellResponseData = zscore(LogResponseData(CurrentWellIndex,CurrentResponse));
        MDL = cvglmnet(CellFeatureData,CellResponseData);
        Prediction = cvglmnetPredict(MDL,CellFeatureData);
        
        SSTotal = sum((CellResponseData - mean(CellResponseData)).^2);
        Residuals = CellResponseData - Prediction;
        SSResidual = sum(Residuals.^2);
        RSquared = 1 - SSResidual/SSTotal
        
    end
end

%%% DOMINANCE ANALYSIS %%%

% Analysis for all response stains can be found in script for Supplementary figure 4


%% Figure 2B

% pERK - 6.25ng/ml EGF

Wells = [10,19,20];

CurrentStain = 3;
Eval = 0:0.01:12;

WellIndex = find(ismember(LinearIndex,Wells));
WellResponseData = LogResponseData(WellIndex,CurrentStain);

GMModel = fitgmdist(WellResponseData,3);

Mu = GMModel.mu;
[~,LowerGaussian] = min(Mu);
[~,HigherGaussian] = max(Mu);

ClusterIDX = cluster(GMModel,WellResponseData);

LowCells = find(ClusterIDX == LowerGaussian);
HighCells = find(ClusterIDX == HigherGaussian);

LowIndex = WellIndex(LowCells);
HighIndex = WellIndex(HighCells);

NonResponderFeature = PCFeatureData(LowIndex,:);
ResponderFeature = PCFeatureData(HighIndex,:);

GroupIndex = [ones(size(LowIndex,1),1);repmat(2,size(HighIndex,1),1)];

% Get Random Balanced Cells....
IndexNo = find(GroupIndex == 1);
IndexYes = find(GroupIndex == 2);

AmountRandom = 2000;

ModelCellsNo = datasample(IndexNo,AmountRandom,'Replace',false);
ModelCellsYes = datasample(IndexYes,AmountRandom,'Replace',false);
ModelCells = [ModelCellsNo;ModelCellsYes];

FeatureDataModel = [NonResponderFeature(:,:);ResponderFeature(:,:)];
MDL = cvglmnet(FeatureDataModel(ModelCells,:),GroupIndex(ModelCells),'binomial');
FitIndex = cvglmnetPredict(MDL,FeatureDataModel(ModelCells,:),'lambda_1se','class');

ModelStats = confusionmatStats(GroupIndex(ModelCells),FitIndex);

% TestCells

TestCellsNo = setdiff(IndexNo,ModelCellsNo);
TestCellsYes = setdiff(IndexYes,ModelCellsYes);
TestCells = [TestCellsNo;TestCellsYes];

FitIndexTest = cvglmnetPredict(MDL,FeatureDataModel(TestCells,:),'lambda_1se','class');
ModelStatsTest = confusionmatStats(GroupIndex(TestCells),FitIndexTest);

ConfusionMat = ModelStatsTest.confusionMat;

ConfusionMatNormed = zeros(2,2);
ConfusionMatNormed(1,:) = ConfusionMat(1,:)./sum(ConfusionMat(1,:));
ConfusionMatNormed(2,:) = ConfusionMat(2,:)./sum(ConfusionMat(2,:));
% ConfusionMatNormed

PlotMatrix = [flipud(ConfusionMatNormed),zeros(2,1);zeros(1,3)];
figure
pcolor(PlotMatrix)
caxis([0 1])
colormap(brewermap(500,'blues'))
axis image
colorbar
title('ConfusionMatrix pERK 6.25ng/ml EGF')


% pAKT - 6.25ng/ml EGF

Wells = [10,19,20];

CurrentStain = 33;
Eval = 0:0.01:12;

WellIndex = find(ismember(LinearIndex,Wells));
WellResponseData = LogResponseData(WellIndex,CurrentStain);

GMModel = fitgmdist(WellResponseData,3);

Mu = GMModel.mu;
[~,LowerGaussian] = min(Mu);
[~,HigherGaussian] = max(Mu);

ClusterIDX = cluster(GMModel,WellResponseData);

LowCells = find(ClusterIDX == LowerGaussian);
HighCells = find(ClusterIDX == HigherGaussian);

LowIndex = WellIndex(LowCells);
HighIndex = WellIndex(HighCells);

NonResponderFeature = PCFeatureData(LowIndex,:);
ResponderFeature = PCFeatureData(HighIndex,:);

GroupIndex = [ones(size(LowIndex,1),1);repmat(2,size(HighIndex,1),1)];

% Get Random Balanced Cells....
IndexNo = find(GroupIndex == 1);
IndexYes = find(GroupIndex == 2);

AmountRandom = 2000;

ModelCellsNo = datasample(IndexNo,AmountRandom,'Replace',false);
ModelCellsYes = datasample(IndexYes,AmountRandom,'Replace',false);
ModelCells = [ModelCellsNo;ModelCellsYes];

FeatureDataModel = [NonResponderFeature(:,:);ResponderFeature(:,:)];
MDL = cvglmnet(FeatureDataModel(ModelCells,:),GroupIndex(ModelCells),'binomial');
FitIndex = cvglmnetPredict(MDL,FeatureDataModel(ModelCells,:),'lambda_1se','class');

ModelStats = confusionmatStats(GroupIndex(ModelCells),FitIndex);

% TestCells

TestCellsNo = setdiff(IndexNo,ModelCellsNo);
TestCellsYes = setdiff(IndexYes,ModelCellsYes);
TestCells = [TestCellsNo;TestCellsYes];

FitIndexTest = cvglmnetPredict(MDL,FeatureDataModel(TestCells,:),'lambda_1se','class');
ModelStatsTest = confusionmatStats(GroupIndex(TestCells),FitIndexTest);

ConfusionMat = ModelStatsTest.confusionMat;

ConfusionMatNormed = zeros(2,2);
ConfusionMatNormed(1,:) = ConfusionMat(1,:)./sum(ConfusionMat(1,:));
ConfusionMatNormed(2,:) = ConfusionMat(2,:)./sum(ConfusionMat(2,:));
% ConfusionMatNormed

PlotMatrix = [flipud(ConfusionMatNormed),zeros(2,1);zeros(1,3)];
figure
pcolor(PlotMatrix)
caxis([0 1])
colormap(brewermap(500,'blues'))
axis image
colorbar
title('ConfusionMatrix pAKT 6.25ng/ml EGF')


% pRSK - 6.25ng/ml EGF

Wells = [7,8,9];

CurrentStain = 123;
Eval = 0:0.01:12;

WellIndex = find(ismember(LinearIndex,Wells));
WellResponseData = LogResponseData(WellIndex,CurrentStain);

GMModel = fitgmdist(WellResponseData,3);

Mu = GMModel.mu;
[~,LowerGaussian] = min(Mu);
[~,HigherGaussian] = max(Mu);

ClusterIDX = cluster(GMModel,WellResponseData);

LowCells = find(ClusterIDX == LowerGaussian);
HighCells = find(ClusterIDX == HigherGaussian);

LowIndex = WellIndex(LowCells);
HighIndex = WellIndex(HighCells);

NonResponderFeature = PCFeatureData(LowIndex,:);
ResponderFeature = PCFeatureData(HighIndex,:);

GroupIndex = [ones(size(LowIndex,1),1);repmat(2,size(HighIndex,1),1)];

% Get Random Balanced Cells....
IndexNo = find(GroupIndex == 1);
IndexYes = find(GroupIndex == 2);

AmountRandom = 2000;

ModelCellsNo = datasample(IndexNo,AmountRandom,'Replace',false);
ModelCellsYes = datasample(IndexYes,AmountRandom,'Replace',false);
ModelCells = [ModelCellsNo;ModelCellsYes];

FeatureDataModel = [NonResponderFeature(:,:);ResponderFeature(:,:)];
MDL = cvglmnet(FeatureDataModel(ModelCells,:),GroupIndex(ModelCells),'binomial');
FitIndex = cvglmnetPredict(MDL,FeatureDataModel(ModelCells,:),'lambda_1se','class');

ModelStats = confusionmatStats(GroupIndex(ModelCells),FitIndex);

% TestCells

TestCellsNo = setdiff(IndexNo,ModelCellsNo);
TestCellsYes = setdiff(IndexYes,ModelCellsYes);
TestCells = [TestCellsNo;TestCellsYes];

FitIndexTest = cvglmnetPredict(MDL,FeatureDataModel(TestCells,:),'lambda_1se','class');
ModelStatsTest = confusionmatStats(GroupIndex(TestCells),FitIndexTest);

ConfusionMat = ModelStatsTest.confusionMat;

ConfusionMatNormed = zeros(2,2);
ConfusionMatNormed(1,:) = ConfusionMat(1,:)./sum(ConfusionMat(1,:));
ConfusionMatNormed(2,:) = ConfusionMat(2,:)./sum(ConfusionMat(2,:));
% ConfusionMatNormed

PlotMatrix = [flipud(ConfusionMatNormed),zeros(2,1);zeros(1,3)];
figure
pcolor(PlotMatrix)
caxis([0 1])
colormap(brewermap(500,'blues'))
axis image
colorbar
title('ConfusionMatrix pRSK 10ng/ml EGF')


% pGSK3B - 6.25ng/ml EGF

Wells = [10,19,20];

CurrentStain = 153;
Eval = 0:0.01:12;

WellIndex = find(ismember(LinearIndex,Wells));
WellResponseData = LogResponseData(WellIndex,CurrentStain);

GMModel = fitgmdist(WellResponseData,3);

Mu = GMModel.mu;
[~,LowerGaussian] = min(Mu);
[~,HigherGaussian] = max(Mu);

ClusterIDX = cluster(GMModel,WellResponseData);

LowCells = find(ClusterIDX == LowerGaussian);
HighCells = find(ClusterIDX == HigherGaussian);

LowIndex = WellIndex(LowCells);
HighIndex = WellIndex(HighCells);

NonResponderFeature = PCFeatureData(LowIndex,:);
ResponderFeature = PCFeatureData(HighIndex,:);

GroupIndex = [ones(size(LowIndex,1),1);repmat(2,size(HighIndex,1),1)];

% Get Random Balanced Cells....
IndexNo = find(GroupIndex == 1);
IndexYes = find(GroupIndex == 2);

AmountRandom = 2000;

ModelCellsNo = datasample(IndexNo,AmountRandom,'Replace',false);
ModelCellsYes = datasample(IndexYes,AmountRandom,'Replace',false);
ModelCells = [ModelCellsNo;ModelCellsYes];

FeatureDataModel = [NonResponderFeature(:,:);ResponderFeature(:,:)];
MDL = cvglmnet(FeatureDataModel(ModelCells,:),GroupIndex(ModelCells),'binomial');
FitIndex = cvglmnetPredict(MDL,FeatureDataModel(ModelCells,:),'lambda_1se','class');

ModelStats = confusionmatStats(GroupIndex(ModelCells),FitIndex);

% TestCells

TestCellsNo = setdiff(IndexNo,ModelCellsNo);
TestCellsYes = setdiff(IndexYes,ModelCellsYes);
TestCells = [TestCellsNo;TestCellsYes];

FitIndexTest = cvglmnetPredict(MDL,FeatureDataModel(TestCells,:),'lambda_1se','class');
ModelStatsTest = confusionmatStats(GroupIndex(TestCells),FitIndexTest);

ConfusionMat = ModelStatsTest.confusionMat;

ConfusionMatNormed = zeros(2,2);
ConfusionMatNormed(1,:) = ConfusionMat(1,:)./sum(ConfusionMat(1,:));
ConfusionMatNormed(2,:) = ConfusionMat(2,:)./sum(ConfusionMat(2,:));
% ConfusionMatNormed

PlotMatrix = [flipud(ConfusionMatNormed),zeros(2,1);zeros(1,3)];
figure
pcolor(PlotMatrix)
caxis([0 1])
colormap(brewermap(500,'blues'))
axis image
colorbar
title('ConfusionMatrix pGSK3B 10ng/ml EGF')


%% Comparison between splitting into training/test and just extensive crossvalidation

%%% Since they yield nigh indistinguishable results, to save a lot of computational time some of the code provided uses only crossvalidation while all data generated for the figures always used train/test and cross val. Please use this as template in case you want to try both for the following analyses (in all the figures) %%%

% Calculations for RSquare Matrix - Just Crossval

CurrentResponseVector = [18,168,3,123,153,108,33,91,61,78];
NameCell = {'pEGFR','pMEK','pERK','pRSK','pGSK3B','pMTOR','pAKT','FoxO1','FoxO3a','pS6'};

WellGroups = {[13,14,15],[10,19,20],[7,8,9],[4,5,6],[1,2,3]};

ConcentrationString = {'0ng','6.25ng','10ng','25ng','100ng'};
RSquareStorageCVAL = zeros(10,5);

for CurrentResponseIndex = 1:size(CurrentResponseVector,2)
    CurrentResponse = CurrentResponseVector(CurrentResponseIndex);

    for CurrentGroup = 1:size(WellGroups,2)
        
        CurrentWells = WellGroups{1,CurrentGroup};       
        % Calculation of RSquared - Depends on the way it's calculated and the crossevaluation set(varies by about ~0.03 for each stain); here we use the most "canonical" definition
        CurrentWellIndex = find(ismember(LinearIndex,CurrentWells));
        CellFeatureData = PCFeatureData(CurrentWellIndex,:);
        CellResponseData = zscore(LogResponseData(CurrentWellIndex,CurrentResponse));
        MDL = cvglmnet(CellFeatureData,CellResponseData);
        Prediction = cvglmnetPredict(MDL,CellFeatureData);
        
        SSTotal = sum((CellResponseData - mean(CellResponseData)).^2);
        Residuals = CellResponseData - Prediction;
        SSResidual = sum(Residuals.^2);
        RSquared = 1 - SSResidual/SSTotal;
        RSquareStorageCVAL(CurrentResponseIndex,CurrentGroup) = RSquared;       
    end   
end


% Calculations for RSquare Matrix - Split

% Generate UMAP - CAVEAT!!!!! EVERY UMAP RUN CAN DIFFER
WellIndex = find(ismember(LinearIndex,[1,2,3,4,5,6,7,8,9,10,19,20,13,14,15]));
ReducedLinearIndex = LinearIndex(WellIndex);

ReducedResponseData = LogResponseData(WellIndex,:);
ReducedFeatureData = PCFeatureData(WellIndex,:);


CurrentResponseVector = [18,168,3,123,153,108,33,91,61,78];
NameCell = {'pEGFR','pMEK','pERK','pRSK','pGSK3B','pMTOR','pAKT','FoxO1','FoxO3a','pS6'};

WellGroups = {[13,14,15],[10,19,20],[7,8,9],[4,5,6],[1,2,3]};

ConcentrationString = {'0ng','6.25ng','10ng','25ng','100ng'};
RSquareStorageSplit = zeros(10,5);

for CurrentResponseIndex = 1:size(CurrentResponseVector,2)
    CurrentResponse = CurrentResponseVector(CurrentResponseIndex);
    for CurrentGroup = 1:size(WellGroups,2)
        
        CurrentWells = WellGroups{1,CurrentGroup};
        StoragePrediction = [];
        StorageTrue = [];
        
        % Predict Replicate one
        TrueWell = CurrentWells(1);
        IndWell = CurrentWells(2:3);
        
        WellIndexTrue = find(ismember(ReducedLinearIndex,TrueWell));
        WellIndexInd = find(ismember(ReducedLinearIndex,IndWell));
        
        TrueResponseData = zscore(ReducedResponseData(WellIndexTrue,CurrentResponse));
        IndResponseData = zscore(ReducedResponseData(WellIndexInd,CurrentResponse));
        
        TrueFeatureData = ReducedFeatureData(WellIndexTrue,:);
        IndFeatureData = ReducedFeatureData(WellIndexInd,:);
        
        MDL = cvglmnet(IndFeatureData,IndResponseData);
        Prediction = cvglmnetPredict(MDL,TrueFeatureData);
        
        CurrentNormData = Prediction;

        Iterations = 20;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([TrueResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        StoragePrediction = [StoragePrediction;CurrentNormData];
        StorageTrue = [StorageTrue;TrueResponseData];
        
        % Predict Replicate two
        TrueWell = CurrentWells(2);
        IndWell = CurrentWells([1,3]);
        
        WellIndexTrue = find(ismember(ReducedLinearIndex,TrueWell));
        WellIndexInd = find(ismember(ReducedLinearIndex,IndWell));
        
        TrueResponseData = zscore(ReducedResponseData(WellIndexTrue,CurrentResponse));
        IndResponseData = zscore(ReducedResponseData(WellIndexInd,CurrentResponse));
        
        TrueFeatureData = ReducedFeatureData(WellIndexTrue,:);
        IndFeatureData = ReducedFeatureData(WellIndexInd,:);
        
        MDL = cvglmnet(IndFeatureData,IndResponseData);
        Prediction = cvglmnetPredict(MDL,TrueFeatureData);
        
        CurrentNormData = Prediction;

        Iterations = 20;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([TrueResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        StoragePrediction = [StoragePrediction;CurrentNormData];
        StorageTrue = [StorageTrue;TrueResponseData];
        
        % Predict Replicate three
        TrueWell = CurrentWells(3);
        IndWell = CurrentWells(1:2);
        
        WellIndexTrue = find(ismember(ReducedLinearIndex,TrueWell));
        WellIndexInd = find(ismember(ReducedLinearIndex,IndWell));
        
        TrueResponseData = zscore(ReducedResponseData(WellIndexTrue,CurrentResponse));
        IndResponseData = zscore(ReducedResponseData(WellIndexInd,CurrentResponse));
        
        TrueFeatureData = ReducedFeatureData(WellIndexTrue,:);
        IndFeatureData = ReducedFeatureData(WellIndexInd,:);
        
        MDL = cvglmnet(IndFeatureData,IndResponseData);
        Prediction = cvglmnetPredict(MDL,TrueFeatureData);
        
        CurrentNormData = Prediction;

        Iterations = 20;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([TrueResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        StoragePrediction = [StoragePrediction;CurrentNormData];
        StorageTrue = [StorageTrue;TrueResponseData];
        
        SSTotal = sum((StorageTrue - mean(StorageTrue)).^2);
        Residuals = StorageTrue - StoragePrediction;
        SSResidual = sum(Residuals.^2);
        RSquared = 1 - SSResidual/SSTotal;
        RSquareStorageSplit(CurrentResponseIndex,CurrentGroup) = RSquared;
        

    end  

end


%% Figure 2C
WellIndex = find(ismember(LinearIndex,[1,2,3,4,5,6,7,8,9,10,19,20,13,14,15]));
ReducedResponseData = LogResponseData(WellIndex,:);
ReducedFeatureData = PCFeatureData(WellIndex,:);
CurrentResponseVector = [3];
NameCell = {'pERK'};

%CustomColorMap = parula(1000);
CustomColorMap = gistColorMap(:,1:3);


WellGroups = {[13,14,15],[10,19,20],[7,8,9],[4,5,6],[1,2,3]};
ConcentrationString = {'0','6.25ng','10ng','25ng','1000ng'};
for CurrentResponseIndex = 1
    CurrentResponse = CurrentResponseVector(CurrentResponseIndex);
    for CurrentGroup = 1:5
        % Plot Measured
        CurrentWells = WellGroups{1,CurrentGroup};
        CurrentWellIndex = find(ismember(ReducedLinearIndex,CurrentWells));
        
        CellResponseData = ReducedResponseData(CurrentWellIndex,CurrentResponse);
        figure
        scatter(ReductionUmap(CurrentWellIndex,1),ReductionUmap(CurrentWellIndex,2),4,CellResponseData,'filled');
        caxis([2 11])
        colormap(CustomColorMap)
        ylim([-4.3 6.8])
        xlim([-7.5 10.5])     
        
        set(gcf,'position',[2963 -211 590.8 450])
        axis off
        

        
        set(gcf,'position',[2963 -211 590.8 450])
        axis on
        colorbar

        
        StoragePrediction = [];
        
        % Predict Replicate one
        TrueWell = CurrentWells(1);
        IndWell = CurrentWells(2:3);
        
        WellIndexTrue = find(ismember(ReducedLinearIndex,TrueWell));
        WellIndexInd = find(ismember(ReducedLinearIndex,IndWell));
        
        TrueResponseData = ReducedResponseData(WellIndexTrue,CurrentResponse);
        IndResponseData = ReducedResponseData(WellIndexInd,CurrentResponse);
        
        TrueFeatureData = ReducedFeatureData(WellIndexTrue,:);
        IndFeatureData = ReducedFeatureData(WellIndexInd,:);
        
        MDL = cvglmnet(IndFeatureData,IndResponseData);
        Prediction = cvglmnetPredict(MDL,TrueFeatureData);
        
        CurrentNormData = Prediction;

        Iterations = 20;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([TrueResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        StoragePrediction = [StoragePrediction;CurrentNormData];
        
        % Predict Replicate two
        TrueWell = CurrentWells(2);
        IndWell = CurrentWells([1,3]);
        
        WellIndexTrue = find(ismember(ReducedLinearIndex,TrueWell));
        WellIndexInd = find(ismember(ReducedLinearIndex,IndWell));
        
        TrueResponseData = ReducedResponseData(WellIndexTrue,CurrentResponse);
        IndResponseData = ReducedResponseData(WellIndexInd,CurrentResponse);
        
        TrueFeatureData = ReducedFeatureData(WellIndexTrue,:);
        IndFeatureData = ReducedFeatureData(WellIndexInd,:);
        
        MDL = cvglmnet(IndFeatureData,IndResponseData);
        Prediction = cvglmnetPredict(MDL,TrueFeatureData);
        
        CurrentNormData = Prediction;

        Iterations = 20;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([TrueResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        StoragePrediction = [StoragePrediction;CurrentNormData];
        
        % Predict Replicate three
        TrueWell = CurrentWells(3);
        IndWell = CurrentWells(1:2);
        
        WellIndexTrue = find(ismember(ReducedLinearIndex,TrueWell));
        WellIndexInd = find(ismember(ReducedLinearIndex,IndWell));
        
        TrueResponseData = ReducedResponseData(WellIndexTrue,CurrentResponse);
        IndResponseData = ReducedResponseData(WellIndexInd,CurrentResponse);
        
        TrueFeatureData = ReducedFeatureData(WellIndexTrue,:);
        IndFeatureData = ReducedFeatureData(WellIndexInd,:);
        
        MDL = cvglmnet(IndFeatureData,IndResponseData);
        Prediction = cvglmnetPredict(MDL,TrueFeatureData);
        
        CurrentNormData = Prediction;

        Iterations = 20;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([TrueResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        StoragePrediction = [StoragePrediction;CurrentNormData];
        
        figure
        scatter(ReductionUmap(CurrentWellIndex,1),ReductionUmap(CurrentWellIndex,2),4,StoragePrediction,'filled');
        caxis([2 11])
        colormap(CustomColorMap)
        ylim([-4.3 6.8])
        xlim([-7.5 10.5])
        set(gcf,'position',[2963 -211 590.8 450])
        axis off
        
        
        set(gcf,'position',[2963 -211 590.8 450])
        axis on
        colorbar

           
    end
end



% Calculations for RSquare Matrix

CurrentResponseVector = [18,168,3,123,153,108,33,91,61,78];
NameCell = {'pEGFR','pMEK','pERK','pRSK','pGSK3B','pMTOR','pAKT','FoxO1','FoxO3a','pS6'};

WellGroups = {[13,14,15],[10,19,20],[7,8,9],[4,5,6],[1,2,3]};

ConcentrationString = {'0ng','6.25ng','10ng','25ng','100ng'};
RSquareStorage = zeros(10,5);
RSquareStoragePooled = zeros(10,1);
for CurrentResponseIndex = 1:size(CurrentResponseVector,2)
    CurrentResponse = CurrentResponseVector(CurrentResponseIndex);
    StorageTrue = [];
    StoragePrediction = [];
    for CurrentGroup = 1:size(WellGroups,2)
        
        CurrentWells = WellGroups{1,CurrentGroup};       
        % Calculation of RSquared - Depends on the way it's calculated and the crossevaluation set(varies by about ~0.03 for each stain); here we use the most "canonical" definition
        CurrentWellIndex = find(ismember(LinearIndex,CurrentWells));
        CellFeatureData = PCFeatureData(CurrentWellIndex,:);
        CellResponseData = zscore(LogResponseData(CurrentWellIndex,CurrentResponse));
        MDL = cvglmnet(CellFeatureData,CellResponseData);
        Prediction = cvglmnetPredict(MDL,CellFeatureData);
        
        SSTotal = sum((CellResponseData - mean(CellResponseData)).^2);
        Residuals = CellResponseData - Prediction;
        SSResidual = sum(Residuals.^2);
        RSquared = 1 - SSResidual/SSTotal;
        RSquareStorage(CurrentResponseIndex,CurrentGroup) = RSquared;
        
        StorageTrue = [StorageTrue;CellResponseData];
        StoragePrediction = [StoragePrediction;Prediction];
    end
    
    % RSquare for pooled
    RSquareStoragePooled(CurrentResponseIndex,1) = corr(StorageTrue,StoragePrediction).^2;
end

% Plot per dose RSquare Matrix

PlotMatrix = [flipud(RSquareStorage),zeros(10,1);zeros(1,6)];

figure
pcolor(PlotMatrix)
caxis([0 1])
colormap(brewermap(500,'blues'))
axis image
yticks([1.5:1:10.5])
yticklabels(fliplr(NameCell))
colorbar
xticks([1.5:1:5.5])
xticklabels(ConcentrationString)
xtickangle(90)

% Plot pooled RSquare

PlotMatrix = [flipud(RSquareStoragePooled),zeros(10,1);zeros(1,2)];

figure
pcolor(PlotMatrix)
caxis([0 1])
colormap(brewermap(500,'blues'))
axis image
yticks([1.5:1:10.5])
yticklabels(fliplr(NameCell))
colorbar
xticks([1.5])
xticklabels({'pooled'})
xtickangle(90)




%% Figure 2D


FavoriteStains = [18,168,3,123,153,108,33,91,61,78];
WellGroups = {[10,19,20],[9,8,7],[3,2,1]};

for CurrentResponseIndex = 3%1:size(FavoriteStains,2)
    
    CurrentResponse = FavoriteStains(CurrentResponseIndex);
    figure(1)
    hold on
    figure(2)
    hold on
    Eval = 0:0.1:12;
    for CurrentWell = 1:size(WellGroups,2)
        CurrentWellIndex = find(ismember(LinearIndex,WellGroups{1,CurrentWell}));
        CurrentResponseData = LogResponseData(CurrentWellIndex,CurrentResponse);
        % Predict Residuals from State...
        CurrentFeatureData = PCFeatureData(CurrentWellIndex,:);
        MDL = cvglmnet(CurrentFeatureData,CurrentResponseData);
        Prediction = cvglmnetPredict(MDL,CurrentFeatureData);
        Coefficients = cvglmnetCoef(MDL);
        Residuals = Prediction - CurrentResponseData;        
        CorrectedData = Residuals + Coefficients(1);
        
        figure(1)
        Density = ksdensity(CorrectedData,Eval);
        
        if CurrentWell == 3
        plot(Eval,Density.*0.66);
        else
          plot(Eval,ksdensity(CorrectedData,Eval));  
        end
        
        CurrentNormData = Prediction;

        Iterations = 2;
        
        for CurrentIteration = 1:Iterations
            NormedData = quantilenorm([CurrentResponseData,CurrentNormData]);
            CurrentNormData = NormedData(:,2);
        end
        
        Prediction = CurrentNormData;
        
        figure(2)
        plot(Eval,ksdensity(Prediction,Eval));
 
    end
end

figure(1)
legend('6.25ng/ml EGF','10ng/ml EGF','100ng/ml EGF')
legend off
axis square

xlabel('log2 mean signal (a.u.)')
ylabel('Density')
ylim([0 2.4])



figure(2)
legend('6.25ng/ml EGF','10ng/ml EGF','100ng/ml EGF')
legend off
axis square

xlabel('log2 mean signal (a.u.)')
ylabel('Density')
ylim([0 1.2])





%% Figure 2E


FavoriteStains = [18,168,3,123,153,108,33,91,61,78];
WellGroups = {[13,14,15],[10,19,20],[9,8,7],[6,5,4],[3,2,1]};


StorageMean = zeros(10,5);
StorageRange = zeros(10,5);
StorageMeanSignal = zeros(10,5);

for CurrentResponseIndex = 1:size(FavoriteStains,2)
    
    CurrentResponse = FavoriteStains(CurrentResponseIndex);
    % Between Group
    MeanSamples = zeros(5,1);
    
    
    for CurrentWell = 1:size(WellGroups,2)
        CurrentWellIndex = find(ismember(LinearIndex,WellGroups{1,CurrentWell}));
        CurrentResponseData = LogResponseData(CurrentWellIndex,CurrentResponse);
        MeanSamples(CurrentWell,1) = mean(CurrentResponseData);
    end
    
   
    StorageMean(CurrentResponseIndex,:) = MeanSamples;
    
    Range = zeros(5,1);
    for CurrentWell = 1:size(WellGroups,2)
        CurrentWellIndex = find(ismember(LinearIndex,WellGroups{1,CurrentWell}));
        CurrentResponseData = LogResponseData(CurrentWellIndex,CurrentResponse);
        CurrentFeatureData = PCFeatureData(CurrentWellIndex,:);
        MDL = cvglmnet(CurrentFeatureData,CurrentResponseData);
        Prediction = cvglmnetPredict(MDL,CurrentFeatureData);
        PercentileRange = prctile(Prediction,[2.5,97.5]);
        Range(CurrentWell,1) = PercentileRange(2) - PercentileRange(1);
    end
    
    StorageRange(CurrentResponseIndex,:) = Range;
    
end

MeanShifts = zeros(10,10);

for CurrentResponse = 1:10
    MeanIndex = 1:5;
    Combinations = nchoosek(MeanIndex,2);
    for CurrentCombination = 1:size(Combinations,1)
        MeanShifts(CurrentResponse,CurrentCombination) = abs(StorageMean(CurrentResponse,Combinations(CurrentCombination,2)) - StorageMean(CurrentResponse,Combinations(CurrentCombination,1)));
        
    end
end

% Plot Matrix 

CombinedVariance = [StorageRange,zeros(10,1),MeanShifts(:,[1,5,8,10]),zeros(10,1),MeanShifts(:,[2,6,9]),zeros(10,1),MeanShifts(:,[3,7]),zeros(10,1),MeanShifts(:,[4])];
NormedVariance = CombinedVariance./max(CombinedVariance,[],2);

% Change in CS

PlotMatrix = NormedVariance(:,1:5);
PlotMatrix = [flipud(PlotMatrix),zeros(10,1)];
PlotMatrix = [PlotMatrix;zeros(1,6)];

figure
pcolor(PlotMatrix)
axis image
colormap(brewermap(500,'Blues'));
caxis([0 1])
title('Change in State')



% Change in EGF - 1

PlotMatrix = NormedVariance(:,7:10);
PlotMatrix = [flipud(PlotMatrix),zeros(10,1)];
PlotMatrix = [PlotMatrix;zeros(1,5)];

figure
pcolor(PlotMatrix)
axis image
colormap(brewermap(500,'Blues'));
caxis([0 1])
title('Change in EGF')



% Change in EGF - 2

PlotMatrix = NormedVariance(:,12:14);
PlotMatrix = [flipud(PlotMatrix),zeros(10,1)];
PlotMatrix = [PlotMatrix;zeros(1,4)];

figure
pcolor(PlotMatrix)
axis image
colormap(brewermap(500,'Blues'));
caxis([0 1])
title('Change in EGF')



% Change in EGF - 3

PlotMatrix = NormedVariance(:,16:17);
PlotMatrix = [flipud(PlotMatrix),zeros(10,1)];
PlotMatrix = [PlotMatrix;zeros(1,3)];

figure
pcolor(PlotMatrix)
axis image
colormap(brewermap(500,'Blues'));
caxis([0 1])
title('Change in EGF')




% Change in EGF - 4

PlotMatrix = NormedVariance(:,19);
PlotMatrix = [flipud(PlotMatrix),zeros(10,1)];
PlotMatrix = [PlotMatrix;zeros(1,2)];

figure
pcolor(PlotMatrix)
axis image
colormap(brewermap(500,'Blues'));
caxis([0 1])
title('Change in EGF')




% yticks(1:10);
% xticks(1:19)
% yticklabels({'pEGFR','pMEK','pERK','pRSK','pGSK3B','pMTOR','pAKT','FoxO1','FoxO3a','pS6'})
% xticklabels({'Cell state var 0','Cell State var 6.25','Cell state var 10','Cell state var 25','Cell state var 100','','EGF var 0-6.25','EGF var 6.25-10','EGF var 10-25','EGF var 25-100','','EGF var 0-10','EGF var 6.25-25','EGF var 10-100','','EGF var 0-25','EGF var 6.25-100','','EGF var 0-100'})
% xtickangle(90)
% colorbar


% Scatter plot of variation induced by change in [EGF] versus variation induced by cellular state

figure
scatter(abs(mean(MeanShifts,2)),mean(StorageRange,2),'filled','MarkerFaceColor','k')
TextStorage = {'pEGFR','pMEK','pERK','pRSK','pGSK3B','pMTOR','pAKT','FoxO1','FoxO3a','pS6'};

for CurrentResponse = 1:size(TextStorage,2)
    text(abs(mean(MeanShifts(CurrentResponse,:))),mean(StorageRange(CurrentResponse,:)),TextStorage{1,CurrentResponse});
end
line([0 4],[0 4],'Color','k')
axis equal
xlim([0 4])
ylim([0 4])
ylabel('Average Variation by Cellular State')
xlabel('Average Variation by shift in EGF concentration')


